# Compétence 6 – Collaborer au sein d’une équipe informatique

Même si j’ai été seul sur le développement de l’application interne (Vue.js) destinée à être utilisée sur des tablettes
en réseau local, j’ai systématiquement raisonné comme si d’autres développeurs allaient reprendre ou étendre mon
travail. Cette posture m’a conduit à formaliser mes choix techniques, à structurer le code et à amorcer une
documentation. La collaboration s’est donc exprimée de manière “anticipée” : je prépare un terrain compréhensible,
maintenable et évolutif plutôt que de laisser un ensemble de décisions implicites.

La première problématique concrète est née des conditions d’usage : les tablettes peuvent subir des coupures réseau.
J’ai analysé le risque principal (perte de données affichées, impressions de lenteur, répétition de requêtes inutiles)
et j’ai exploré des solutions de cache côté client. J’ai distingué deux pistes : utiliser directement IndexedDB pour
mettre en cache des données de consultation relativement stables, ou intégrer une couche plus riche comme RxDB offrant
synchronisation réactive et gestion de conflits. Après lecture de retours communautaires (issues GitHub, discussions sur
Reddit et Hacker News) et tests rapides, j’ai conclu que RxDB introduisait une complexité prématurée par rapport à mon
besoin immédiat. J’ai donc retenu une approche incrémentale : poser une stratégie de cache simple adossée à IndexedDB
pour certaines collections et laisser ouverte la porte à une évolution vers RxDB si, plus tard, l’écriture hors‑ligne et
la résolution de conflits devenaient indispensables.

Parallèlement, la croissance fonctionnelle de l’application avait progressivement enflé certains stores Pinia :
accumulation d’état, appels API entremêlés, duplication de logique de chargement et de gestion d’erreurs. Constatant que
ce modèle rendrait difficile l’arrivée d’un nouveau développeur, j’ai entrepris une refactorisation. Ma veille m’a
conduit à TanStack Query, dont j’ai évalué la pertinence pour Vue : invalidation fine, déduplication d’appels
simultanés, gestion unifiée des états de requête, mécanismes de revalidation et possibilités de pré‑hydratation future
avec un cache persistant. Après un micro‑prototype, j’ai externalisé la logique de récupération de données vers cette
bibliothèque, ne laissant aux stores que l’état réellement métier ou dérivé.

La réflexion sur la résilience réseau et le fetch centralisé a convergé naturellement : TanStack Query offre déjà des
mécanismes de cache en mémoire et de réutilisation de résultats. J’ai planifié leur articulation future avec le stockage
persistant IndexedDB (pré‑hydratation au lancement) pour réduire encore la dépendance aux conditions réseau, documentant
l’enchaînement envisagé afin d’éviter que cette intention reste tacite.

En parallèle, j’ai anticipé les besoins de diagnostic partagé. En cas d’incident, l’absence de traces structurées
devient un frein majeur à toute collaboration (même différée). J’ai comparé Winston et Pino sous l’angle de la
performance, de la simplicité d’intégration et du format de sortie. Winston, très modulable, m’a semblé surdimensionné
pour un contexte interne où je n’avais pas encore de pipeline complexe d’agrégation. Pino, par sa sortie JSON minimale,
correspondait mieux à mon objectif : fournir rapidement des logs structurés (timestamp, niveau, contexte) exploitables
plus tard par un outil de centralisation si l’équipe s’agrandit. Là encore, la décision est explicitée dans la
documentation technique afin que son éventuelle remise en question future parte d’une base argumentée.

<figure>
  <img alt="Vitepress" height="900" src="/portfolio/images_portfolio/exemple_doc.png" width="100%"/>
  <figcaption style="font-size: 1.2em;">
    Illustration 1 : Grafana pour le monitoring de la base de données
  </figcaption>
</figure>

Souhaitant aller au-delà du simple logging, j’ai réalisé un test de supervision de la base de données en assemblant un
exporter PostgreSQL et un tableau de bord Grafana élémentaire. Ce proof of concept ne prétend pas offrir une
observabilité complète, mais il démontre une démarche : exposer des métriques (latence, connexions) et visualiser les
tendances. Cette esquisse de monitoring fournit un point d’appui concret pour une future industrialisation (alertes,
corrélation avec les logs applicatifs).

<figure>
  <img alt="Vitepress" height="900" src="/portfolio/images_portfolio/exemple_doc.png" width="100%"/>
  <figcaption style="font-size: 1.2em;">
    Illustration 2 : VitePress pour la documentation technique
  </figcaption>
</figure>

La dimension collaborative s’exprime enfin dans la documentation. J’ai mis en place un site VitePress qui centralise
l’architecture logique (couches UI, couche d’accès via TanStack Query, stores Pinia allégés), les décisions techniques (
cache IndexedDB vs RxDB, choix de Pino, adoption de TanStack Query) et des exemples d’usage réels. Chaque section est
rédigée dans l’optique d’un onboarding : un lecteur doit comprendre rapidement le pourquoi avant le comment.

<figure id="Histoire">
  <img alt="Histoire" height="900" src="/portfolio/images_portfolio/histoire.png" width="100%"/>
  <figcaption style="font-size: 1.2em;">
    Illustration 3 : Histoire pour la documentation interactive des composants
  </figcaption>
</figure>

En cherchant initialement des outils pour automatiser des tests de bout en bout (notamment en comparant Playwright et
Cypress), je suis tombé sur Histoire (voir [Illustration 4](#Histoire)), un framework orienté documentation interactive
des composants Vue, dans l’esprit de Storybook. Cette découverte parallèle a enrichi ma démarche collaborative : isoler
un composant dans Histoire m’a permis de documenter visuellement ses variantes (états de chargement, erreurs, données
échantillon) et de révéler des props implicites ou mal nommées. J’ai commencé à y déposer les composants transverses (
boutons, formulaires, éléments de liste) avec des scénarios réalistes, préparant ainsi la base d’un futur “design
system” léger. Cette galerie interactive devient un langage commun potentiel : un futur collègue ou un référent métier
peut valider un état d’interface sans parcourir le code, et chaque “story” constitue un point d’ancrage possible pour
des tests E2E scénarisés ultérieurement (réutilisation des mocks et des états documentés). Histoire complète donc
VitePress : l’un porte la structure et les décisions, l’autre incarne les composants et leur comportement concret.

En conclusion, même en l’absence d’équipe autour de moi, j’ai bâti un environnement de travail qui facilite la reprise :
code refactorisé selon des patterns reconnus, choix technologiques justifiés, base de cache évolutive, logging structuré
et début de monitoring. Cette approche démontre à la fois la maîtrise de concepts techniques et la capacité à les mettre
en œuvre de façon structurée, transférable et orientée vers la collaboration à venir.